Algorithm- set of steps or instructions for completing a task

Requirements:
1) clearly defined problem, input and output
2) steps need to be in a specific order
3) steps need to be distinct
4) algorithm should produce a result
5) algorithm should complete in a finite amount of time

Time complexity- measure of how long it takes the algorithm to run
Space complexity- measure of the amount of memory taken up by the computer to run the algorithm
Big O- Theoretical definition of the complexity of an algorithm as a function of the size
It measures the "upper bounds" or worst case senario of the algorithm 

Runtime from best to worst
O(1)- constant time, time does not change with the size of the input. (least complex best case senario)
O(log n) or O(ln n)- logarithmic runtime/ sublinear runtime (ex: binary search)
O(n)- linear runtime (ex: linear search)
O(n log n)- quasilinear or log linear runtime (ex: merge sort) 
O(n^2)- qaudratic runtime, not every efficient (ex: nested iteration(loop inside a loop))
O(n^3)- cubic runtime
O(n^k)- polynomial runtime, considered efficient and likely used in practice (All big O above is polynomial)
O(2^n)- exponential time (ex: brute force method)
O(n!)- factorial time complexity (ex: traveling salesman problem 3!= 3*2*1)

Recursive Function- function that calls on itself (see recursive_binary_search.py)
Always need a stopping condition or base case
Recursive Depth- number of times a recursive function calls on itself

Iterative Function-  function that loops to repeat some part of the code

*Python preferes iterative functions over recursive functions becasue of space complexity*
*However, that is not the case for some other languages such as Swift*