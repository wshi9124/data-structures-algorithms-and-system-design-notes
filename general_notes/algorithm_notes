Algorithm- set of steps or instructions for completing a task

Requirements:
1) clearly defined problem, input and output
2) steps need to be in a specific order
3) steps need to be distinct
4) algorithm should produce a result
5) algorithm should complete in a finite amount of time

Time complexity- measure of how long it takes the algorithm to run
Space complexity- measure of the amount of memory taken up by the computer to run the algorithm
Big O- Theoretical definition of the complexity of an algorithm as a function of the size
It measures the "upper bounds" or worst case senario of the algorithm 

Runtime from best to worst
O(1)- constant time, time does not change with the size of the input. (least complex best case senario)
O(log n) or O(ln n)- logarithmic runtime/ sublinear runtime (ex: binary search)
O(n)- linear runtime (ex: linear search)
O(n log n)- quasilinear or log linear runtime (ex: merge sort) 
O(n^2)- qaudratic runtime, not every efficient (ex: nested iteration(loop inside a loop))(ex: brute force method)
O(n^3)- cubic runtime
O(n^k)- polynomial runtime, considered efficient and likely used in practice (All big O above is polynomial)
O(2^n)- exponential time 
O(n!)- factorial time complexity (ex: traveling salesman problem 3!= 3*2*1)

Recursive Function- function that calls on itself (see recursive.py)
Always need a stopping condition or base case
Recursive Depth- number of times a recursive function calls on itself

Iterative Function- function that loops to repeat some part of the code

Divide And Conquer Technique- some examples that use this technique is quicksort and merge sort
This technique can be divided into the following three parts:
1) Divide: This involves dividing the problem into smaller sub-problems.
2) Conquer: Solve sub-problems by calling recursively until solved.
3) Combine: Combine the sub-problems to get the final solution of the whole problem.


*Python preferes iterative functions over recursive functions becasue of space complexity*
*However, that is not the case for some other languages such as Swift*

Depth First Search(DFS) - algorithm used for nodes and edges of a graph. 
Runs in O(V+E)
V= vertices 
E= edges 
DFS plunges depth first into a graph without regard for which edge it takes next until it cannot go any further at which point it back tracks and continues.
Has to start at a node 